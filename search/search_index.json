{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"MD-Models","text":"<p>Markdown models are a way to define data models in a human-readable format. The models can be used to generate code, documentation and other formats from a single source of truth.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Human-readable - Markdown models are easy to read and write for humans.</li> <li>Extendable - Extension is simple, diffable and mergable with other models.</li> <li>Machine-readable - Convert your model into other schema languages such as JSON Schema, XSD and more.</li> <li>Code generation - Generate code in different programming languages such as Python and Typescript.</li> <li>Documentation - Generate documentation pages for mkdocs.</li> <li>Validation - Validate data against the defined schema.</li> <li>Semantic - Define semantic relationships between data structures.</li> </ul>"},{"location":"#motivation","title":"Motivation","text":"<p>There exist many ways to formalize real-world structures into data schemes and make them machine-readable and thus applicable in software solutions. However, existing schema languages such JSON Schema or XML Schema are often hard to read and write for humans, especially for non-developers. Markdown models aim to provide a human-readable way to define data models and invite users from different backgrounds to contribute to the definition of data models.</p> <p>Wait, not another schema language!</p> <p>We are aware that there are many schema languages out there, and we do not aim to replace them. Instead, we aim to provide a way to define data models in a human-readable format that can be used to convert into other schema languages and programming languages. Our goal is to provide a gateway for non-developers to contribute to the definition of data models and to make the process of defining data models more accessible to a broader audience, while ensuring the integrity into existing solutions.</p>"},{"location":"#how-it-works","title":"How it works","text":"<p>Markdown models are defined in a simple markdown format. The format is based on the CommonMark specification and can be extended with custom syntax. The concept is simple: Level 3 headings initialize a new type and the following list items define the fields of the type.</p> Person.mdPerson.jsonPerson.xsd <pre><code>### Person\n\nThis is a simple data model that describes a person. You can also add\nimages, links and other markdown elements to your documentation.\nFeel free to be creative!\n\n- name\n  - Type: string\n  - Description: Name of the person\n- age\n  - Type: integer\n  - Description: Age of the person\n</code></pre> <pre><code>{\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"description\": \"This is a simple data model that describes a person [...]\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"name\": {\n      \"type\": \"string\",\n      \"description\": \"Name of the person\"\n    },\n    \"age\": {\n      \"type\": \"integer\",\n      \"description\": \"Age of the person\"\n    }\n  },\n  \"required\": [\"name\", \"age\"]\n}\n</code></pre> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"&gt;\n  &lt;xs:element name=\"person\"&gt;\n    &lt;xs:annotation&gt;\n      &lt;xs:documentation&gt;\n        This is a simple data model that describes a person [...]\n      &lt;/xs:documentation&gt;\n    &lt;/xs:annotation&gt;\n    &lt;xs:complexType&gt;\n      &lt;xs:sequence&gt;\n        &lt;xs:element name=\"name\" type=\"xs:string\"&gt;\n          &lt;xs:annotation&gt;\n            &lt;xs:documentation&gt;Name of the person&lt;/xs:documentation&gt;\n          &lt;/xs:annotation&gt;\n        &lt;/xs:element&gt;\n        &lt;xs:element name=\"age\" type=\"xs:integer\"&gt;\n          &lt;xs:annotation&gt;\n            &lt;xs:documentation&gt;Age of the person&lt;/xs:documentation&gt;\n          &lt;/xs:annotation&gt;\n        &lt;/xs:element&gt;\n      &lt;/xs:sequence&gt;\n    &lt;/xs:complexType&gt;\n  &lt;/xs:element&gt;\n&lt;/xs:schema&gt;\n</code></pre> <p>All three formats describe the same data model, but the markdown version offers more readability compared to the JSON and XML versions. In fact, you can even add text/image documentation to any part of your data model and thus communicate the purpose of the data model to other users. The MD-Models library will recognize non-structural elements that are not part of the data model and will not include them in the generated outputs.</p> <p>Want to learn more? Check out the syntax documentation!</p>"},{"location":"#how-to-use","title":"How to use","text":"<p>The MD-Models library is available as a Rust library/binary and can be used to convert and validate markdown data models. We currently support the following templates:</p> <ul> <li>JSON Schema</li> <li>XML Schema Definition (XSD)</li> <li>ShEx</li> <li>SHACL</li> <li>Python-Dataclasses</li> <li>Python-Pydantic</li> <li>Python-Pydantic-XML</li> <li>Typescript Interfaces</li> <li>Markdown Documentation</li> </ul> <p>We are planning to add more templates in the future. If you have a specific template in mind, feel free to open an issue or a pull request. Alternatively, you can also write your own template and use it with the MD-Models library.</p> <p>Want to learn more? Check out the library documentation!</p>"},{"location":"syntax/","title":"Syntax","text":"<p>This guide outlines how to document a data model schema using MD-Models. The goal is to explain the structure and key components of the data model in clear, non-technical language to make it accessible to users who may not have a background in programming. This documentation will also ensure that the data model is organized, easy to maintain, and compatible with various external systems.</p> Full example <pre><code>---\nrepo: https://myrepo.com/datamodel\nprefix: myapp\nprefixes:\n  schema: schema.org\n---\n\n### User (schema:Person)\n\nThis type defines a user profile.\n\n- name\n  - Type: string\n  - Description: The full name of the user.\n  - Term: schema:name\n- address\n  - Type: Address\n  - Description: The user's address.\n- orders\n  - Type: Order[]\n  - Description: Complete list of the user's orders.\n\n### Address\n\nThis object represents a user's address.\n\n- street\n    - Type: string\n    - Description: The street of a user\n    - Term: schema:streetAddress\n- postal_code\n    - Type: string\n    - Description: The postal code of a user\n    - Term: schema:postalCode\n\n### Order\n\nThis object defines an order.\n\n- product_id\n  - Type: string\n  - Description: The ID of the product that has been ordered\n- status\n  - Type: OrderStatus\n  - Description: The current state of the user's order.\n\n### OrderStatus\n\nThis enumeration encodes the possible states an order can be in.\n\nDELIVERED = \"delivered\"\nIN_TRANSIT = \"in_transit\"\nOPEN = \"open\"\n</code></pre>"},{"location":"syntax/#yaml-frontmatter-metadata-definition","title":"YAML Frontmatter: Metadata Definition","text":"<p>At the very beginning of the document, we define what\u2019s called the YAML frontmatter. This section provides important metadata (background information) that gives context to the entire data model. Think of it as the \u201csettings\u201d for your documentation. This metadata helps systems interpret the model correctly, especially if the model needs to work with other systems or tools.</p> <p>Why is the Frontmatter Important?</p> <p>The frontmatter provides key information that serves multiple purposes:</p> <ul> <li>Repository Information: Where is the data model stored? This could be a web address (URL) to a source repository where the model is maintained.</li> <li>Prefix for XML Serialization: If your data model is going to be converted into XML format, it\u2019s essential to define a prefix that ensures each part of the model is properly named and understood by machines.</li> <li>Other Prefixes: You might need to reference common external vocabularies (like schema.org) to make your model interoperable with other data formats.</li> </ul> <p>Example of Frontmatter:</p> <pre><code>---\nrepo: https://myrepo.com/datamodel\nprefix: myapp\nprefixes:\n  schema: schema.org\n---\n</code></pre> <p>Explanation:</p> <ul> <li><code>repo</code>: This is a web address (URL) that points to the repository where the data model is stored. In this example, it\u2019s https://myrepo.com/datamodel.</li> <li><code>prefix</code>: This is the default prefix (myapp) used when the model is serialized into XML. This prefix ensures the data elements are uniquely named.</li> <li><code>prefixes</code>: This section maps additional prefixes to well-known external namespaces, such as schema mapped to schema.org. This helps define standardized data fields like schema:name for names, or schema:address for addresses.</li> </ul>"},{"location":"syntax/#general-description-of-the-data-model","title":"General Description of the Data Model","text":"<p>This section is defined by a level 1 heading (#) and gives an overall summary of the data model. It explains what the data model is about and why it exists, providing a general overview that someone unfamiliar with the model can understand.</p> <p>Why is the General Description Important?</p> <p>The general description serves as an introduction to the data model. It should provide a high-level explanation that answers:</p> <ul> <li>What is the purpose of the data model?</li> <li>What kind of data or entities does it represent?</li> <li>Who would use this model and for what purpose?</li> </ul> <p>This section does not need to be too technical. Its  purpose is to help everyone, regardless of technical background, understand what the model is designed to do.</p> <p>Example of a General Description:</p> <pre><code># My Application Data Model\n\nThis data model defines and describes the key entities and relationships within My Application. The model focuses on users, their addresses, and the various statuses that a user account can have. It provides a structured way to organize and manage data, ensuring consistency across the system and compatibility with external systems like XML and schema.org.\n\nExplanation:\n\n- Entities: In this case, the entities are users, addresses, and account statuses.\n- Purpose: The model provides a way to organize and manage data, ensuring that the system operates consistently and integrates easily with other systems.\n</code></pre> <p>This general description helps someone unfamiliar with the model quickly understand what kind of data is being managed and why.</p>"},{"location":"syntax/#object-definitions","title":"Object Definitions","text":"<p>Objects are the building blocks of the data model. They represent the things or entities within the system that you are tracking or managing. For example, objects can represent people, products, locations, or any other type of entity relevant to your application.</p> <p>What is an Object?</p> <p>An object in the context of a data model is something that you want to store information about. It could be a user, a product, a service, or even something abstract like an event or a status. Objects are usually defined by a name and a set of attributes (properties). Within a markdown data model, an object is defined by a level 3 heading (###).</p> <p>Example of an Object:</p> <pre><code>### User (schema:Person)\n\n- name\n  - Type: string\n</code></pre> <ul> <li>Object name: <code>User</code> \u2013 This represents an individual who uses the application.</li> <li>Namespace reference: <code>schema:Person</code> This maps the object to the standardized <code>Person</code> term from schema.org. By doing this, you ensure that external systems will recognize and understand the object when interacting with your model.</li> </ul> <p>Best Practices for Object Names</p> <ul> <li>Object names should be capitalized and written in PascalCase: This means that each word in the object name should start with a capital letter, and there should be no spaces or underscores between words. This makes object names clear and easy to read.</li> </ul>"},{"location":"syntax/#attributes","title":"Attributes","text":"<p>Attributes define the characteristics or properties of an object. For example, a <code>User</code> object might have attributes like <code>name</code>, <code>email_address</code>, and <code>age</code> These attributes describe specific information about the user. Within markdown data models, an attribute is defined as a list element (-) and has to appear under the object it belongs to.</p> <p>Example of attributes for the <code>User</code> Object:</p> <pre><code>- **name**\n  - Type: string\n  - Description: The full name of the user.\n  - Term: schema:name\n- age\n  - Type: number\n  - Description: The age of the user in years.\n  - Term: schema:age\n</code></pre> <p>Explanation:</p> <ul> <li><code>name</code>: This attribute stores the user\u2019s name. It is a string (a sequence of characters), and it is mapped to the schema:name term from schema.org. By enclosing the attribute name in double asterisks (**), we make it bold and thus required.</li> <li><code>age</code>: This attribute stores the user\u2019s age as a number. It uses the schema:age term, ensuring consistency with other systems that also use this standard.</li> </ul> <p>Best Practices for attribute names</p> <ul> <li>Do not use special characters or numbers at the start of attribute names: This ensures that the names are valid and won\u2019t cause errors when interacting with different systems.</li> <li>Avoid spaces in attribute names: Instead, use underscores (<code>_</code>) to separate words. This ensures that the names are easy to read and consistent.</li> </ul>"},{"location":"syntax/#configuring-attributes","title":"Configuring attributes","text":"<p>You may have noticed that attributes contain a sub-list of key-value pairs. These are used to define specific details about each attribute. You can insert whatever metadata you'd like to add, but there are two mandatory ones:</p> <ul> <li><code>Type</code>: The data-type associated with the attribute. This is vital to check if the values given to an attribute are as expected. For example, a user\u2019s age should be a number, not a string.</li> <li><code>Description</code>: A short description of what the attribute represents. This helps others understand the purpose of the attribute and how it should be used. In addition, these descriptions are helpful to assist OpenAI-based structured respones to extract metadata from text data.</li> </ul> <p>Aside of these mandatory optionals, here are some optional ones:</p> <ul> <li><code>XML</code>: This alias will be used upon XML handling. It can be particularly useful in cases where the JSON snake case notation violates the XML naming conventions.</li> <li><code>Term</code>: This is where you can add ontology terms to identify the semantic meaning of an attribute. You can enter a valid URI or make use of prefixed shortforms such as <code>schema:person</code>. When using the latter, make sure that you have defined the prefix within the YAML frontmatter.</li> </ul> <p>Since markdown data models are a superset of JSON-Schema, you can use any of the JSON-Schema attributes to further define the behavior of your attributes. This includes options like <code>default</code>, <code>minimum</code>, <code>example</code> and more.</p>"},{"location":"syntax/#using-types","title":"Using Types","text":"<p>The <code>Type</code> option of an attribute is a powerful tool to ensure data consistency and accuracy. By specifying the data type of an attribute, you can prevent incorrect values from being entered and ensure that the data is always in the expected format. These are the currently supported base types:</p> <ul> <li><code>string</code>- Text data, such as names, addresses, and descriptions.</li> <li><code>number</code>- Numerical data, such as a length, prices, and quantities. Resolves to <code>float</code></li> <li><code>float</code> - Explicit floating point number type.</li> <li><code>integer</code> - Whole number type, such as ages, counts or IDs.</li> <li><code>boolean</code> - Truth values that can be either <code>true</code>or <code>false</code></li> <li><code>bytes</code> - Raw byte data such as files or images.</li> </ul> <p>In addition to basic types, you can also specify the usage of another object that you have defined within your data model. For instance, if there is an <code>Address</code> object present, you can specify that the <code>address</code> attribute of a <code>User</code> object should be of type <code>Address</code>.</p> <p>When dealing with array/list data, you can tranform any type into an array by adding <code>[]</code> to the end of the type. For example, <code>string[]</code> would represent an array of strings. Same applies to complex types (other objects in your model) as well.</p>"},{"location":"syntax/#enumerations","title":"Enumerations","text":"<p>Enumerations are used when an attribute can only have a specific set of predefined values. These values are usually constant and represent different states or categories. For example, a Status enumeration could represent whether a user\u2019s account is active, inactive, or suspended.</p> <p>What are Enumerations?</p> <p>An enumeration is a list of possible values that an attribute can take. This is especially useful for fields like account status, where only a limited number of values are valid. By using enumerations, you ensure that the data entered is always within the allowed range, reducing errors and improving consistency.</p> <p>Example of an Enumeration:</p> <pre><code>### Status\n\nRepresents the possible states of a user account.\n\nACTIVE = \"active\"\nINACTIVE = \"inactive\"\nSUSPENDED = \"suspended\"\n</code></pre> <p>Explanation:</p> <ul> <li>The Status enumeration defines three possible values that a status attribute can have:</li> <li><code>ACTIVE</code>: The account is active and operational.</li> <li><code>INACTIVE</code>: The account is inactive, possibly due to inactivity or manual suspension.</li> <li><code>SUSPENDED</code>: The account is temporarily or permanently suspended.</li> </ul> <p>By defining enumerations, you restrict the attribute values to valid options, ensuring that no invalid data is entered.</p>"},{"location":"syntax/#namespaces-and-prefixes","title":"Namespaces and Prefixes","text":"<p>Namespaces and prefixes provide a way to align your data model with external standards and ensure that your data is compatible with other systems. A namespace acts as a reference to a specific domain of terms, helping avoid conflicts or confusion when similar terms exist in different systems.</p> <p>Why are Namespaces and Prefixes Important?</p> <p>When you\u2019re building a data model that may need to interact with other systems, it\u2019s important to reference standardized terms. Namespaces allow you to link the terms in your model to well-known vocabularies (like <code>schema.org</code>) so that external systems can recognize and understand your data. By doing this, you make your data model interoperable.</p> <p>Example of prefixes:</p> <pre><code>prefixes:\n  schema: schema.org\n</code></pre> <p>Explanation:</p> <ul> <li>The schema prefix is mapped to schema.org. This means that any term in your model prefixed with schema (like <code>schema:name</code> or <code>schema:address</code>) is directly linked to a globally recognized vocabulary. This helps standardize your data and makes it easier to integrate with other platforms or services.</li> </ul>"},{"location":"syntax/#full-example","title":"Full example","text":"<p>In this section you can find a full example that describes a simple data model for a user profile. This model includes the user\u2019s name, email address, age, and status. It also defines an enumeration for the user status attribute.</p> Click to show <pre><code>---\nrepo: https://myrepo.com/datamodel\nprefix: myapp\nprefixes:\n  schema: schema.org\n---\n\n### User (schema:Person)\n\nThis type defines a user profile.\n\n- name\n  - Type: string\n  - Description: The full name of the user.\n  - Term: schema:name\n- address\n  - Type: Address\n  - Description: The user's address.\n- orders\n  - Type: Order[]\n  - Description: Complete list of the user's orders.\n\n### Address\n\nThis object represents a user's address.\n\n- street\n    - Type: string\n    - Description: The street of a user\n    - Term: schema:streetAddress\n- postal_code\n    - Type: string\n    - Description: The postal code of a user\n    - Term: schema:postalCode\n\n### Order\n\nThis object defines an order.\n\n- product_id\n  - Type: string\n  - Description: The ID of the product that has been ordered\n- status\n  - Type: OrderStatus\n  - Description: The current state of the user's order.\n\n### OrderStatus\n\nThis enumeration encodes the possible states an order can be in.\n\nDELIVERED = \"delivered\"\nIN_TRANSIT = \"in_transit\"\nOPEN = \"open\"\n</code></pre>"},{"location":"syntax/#best-practices","title":"Best Practices","text":"<p>To ensure your data model is clear, well-organized, and compatible with different systems, follow these best practices.</p>"},{"location":"syntax/#object-names","title":"Object Names","text":"<p>Object names should be capitalized and written in PascalCase. This means the first letter of each word is capitalized, and there are no spaces between words. This naming convention improves readability and keeps the documentation consistent. Names should also not start with numbers or special characters.</p> <p>\u2705 Valid Example:</p> <pre><code>### UserOrder\n</code></pre> <p>\u26d4\ufe0f Invalid Examples:</p> <pre><code>### User Order\n\n### 0UserOrder\n</code></pre>"},{"location":"syntax/#attribute-names","title":"Attribute Names","text":"<ul> <li>Attribute names must not start with numbers or special characters. This ensures compatibility with programming languages and data serialization formats.</li> <li>Avoid spaces in attribute names. Instead, use underscores (<code>_</code>) to separate words.</li> </ul> <p>\u2705 Valid Example:</p> <pre><code>- total_price\n  - Type: number\n  - Description: The total price of the order.\n</code></pre> <p>\u26d4\ufe0f Invalid Examples:</p> <pre><code>- total price\n  - Type: number\n  - Description: The total price of the order.\n- 3total price\n  - Type: number\n  - Description: The total price of the order.\n</code></pre>"},{"location":"syntax/#descriptions-for-objects-and-attributes","title":"Descriptions for Objects and Attributes","text":"<p>Always include descriptions for both objects and attributes. These descriptions provide valuable context, helping both human readers and systems (like AI tools) understand the meaning and purpose of each object or attribute.</p> <p>\u2705 Valid Example:</p> <pre><code>### Product (schema:Product)\n\nRepresents an item that is available for purchase in the system.\n\n- name\n  - Type: string\n  - Description: The name of the product.\n</code></pre> <p>\u26a0\ufe0f Bad Practice Example:</p> <pre><code>### Product\n\n- name\n  - Type: string\n</code></pre>"},{"location":"library/","title":"Overview","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"library/code-generation/","title":"Code Generation","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"library/conversion/","title":"Conversion","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"library/pipelines/","title":"Continuous integration","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"library/validation/","title":"Validation","text":"<p>\ud83d\udea7 Under Construction \ud83d\udea7</p>"},{"location":"types/","title":"MD-Models Types","text":"<p>This page contains types that the MD-Models library provides from of the shelf. You can use these types in your own data models by simply referencing them in your data model's attributes <code>Type</code> section.</p>"},{"location":"types/#types-available","title":"Types available","text":"<ul> <li>Unit Definition</li> <li>Equation</li> </ul>"},{"location":"types/#how-to-use","title":"How to use","text":"<p>To use a type in your data model, simply reference it in the <code>Type</code> section of your data model's attribute. For example, to use the <code>UnitDefinition</code> type in your data model, you would write:</p> <pre><code>- unit\n  - Type: UnitDefinition\n  - Description: Unit of the estimated parameter.\n</code></pre> <p>This will add the <code>UnitDefinition</code> type to your data model and can thus be used across your data model. If you like to modify these types, feel free to copy the markdown file to your own project and modify it as you see fit.</p>"},{"location":"types/#contributing","title":"Contributing","text":"<p>If you have a type that you think would be useful for others, feel free to create a pull request to add it to this repository. We are happy to accept any contributions that you think would be useful for others.</p> <p>If you want to propose changes to an existing type, please only edit the corresponding markdown file in this repository. The continuous integration will automatically update the repository in your branch with the changes you propose. After the CI has successfully run, you can create a pull request to merge your changes into the main branch.</p>"},{"location":"types/equation/","title":"Equation","text":"<p>This page provides comprehensive information about the structure and components of the data model, including detailed descriptions of the types and their properties, information on enumerations, and an overview of the ontologies used and their associated prefixes. Below, you will find a graph that visually represents the overall structure of the data model.</p> Graph <pre><code>flowchart TB\n    equation(Equation)\n    eqvariable(EqVariable)\n    eqparameter(EqParameter)\n    equation(Equation) --&gt; eqvariable(EqVariable)\n    equation(Equation) --&gt; eqparameter(EqParameter)\n\n    click equation \"#equation\" \"Go to Equation\"\n    click eqvariable \"#eqvariable\" \"Go to EqVariable\"\n    click eqparameter \"#eqparameter\" \"Go to EqParameter\"</code></pre>"},{"location":"types/equation/#types","title":"Types","text":""},{"location":"types/equation/#equation_1","title":"Equation","text":"<p>Represents an equation that can be used in a data model.</p> <p>equation* <code>string</code></p> <ul> <li>The equation that is used in the data model.</li> </ul> <p>variables <code>list[EqVariable]</code></p> <ul> <li>List of variables that are used in the equation.</li> </ul> <p>parameters <code>list[EqParameter]</code></p> <ul> <li>List of parameters that are used in the equation.</li> </ul>"},{"location":"types/equation/#eqvariable","title":"EqVariable","text":"<p>Represents a variable that is used in the equation.</p> <p>id* <code>string</code></p> <ul> <li>Unique identifier for the variable.</li> </ul> <p>name* <code>string</code></p> <ul> <li>Name of the variable.</li> </ul> <p>symbol <code>string</code></p> <ul> <li>Symbol of the variable.</li> </ul>"},{"location":"types/equation/#eqparameter","title":"EqParameter","text":"<p>Represents a parameter that is used in the equation.</p> <p>id* <code>string</code></p> <ul> <li>Unique identifier for the parameter.</li> </ul> <p>name* <code>string</code></p> <ul> <li>Name of the parameter.</li> </ul> <p>symbol <code>string</code></p> <ul> <li>Symbol of the parameter.</li> </ul> <p>value <code>float</code></p> <ul> <li>Value of the parameter.</li> </ul>"},{"location":"types/unit-definition/","title":"SI Unit","text":"<p>This page provides comprehensive information about the structure and components of the data model, including detailed descriptions of the types and their properties, information on enumerations, and an overview of the ontologies used and their associated prefixes. Below, you will find a graph that visually represents the overall structure of the data model.</p> Graph <pre><code>flowchart TB\n    unitdefinition(UnitDefinition)\n    baseunit(BaseUnit)\n    unittype(UnitType)\n    unitdefinition(UnitDefinition) --&gt; baseunit(BaseUnit)\n    baseunit(BaseUnit) --&gt; unittype(UnitType)\n\n    click unitdefinition \"#unitdefinition\" \"Go to UnitDefinition\"\n    click baseunit \"#baseunit\" \"Go to BaseUnit\"\n    click unittype \"#unittype\" \"Go to UnitType\"</code></pre>"},{"location":"types/unit-definition/#types","title":"Types","text":""},{"location":"types/unit-definition/#unitdefinition","title":"UnitDefinition","text":"<p>Represents a unit definition that is based on the SI unit system.</p> <p>id <code>string</code></p> <ul> <li>Unique identifier of the unit definition.</li> </ul> <p>name <code>string</code></p> <ul> <li>Common name of the unit definition.</li> </ul> <p>base_units <code>list[BaseUnit]</code></p> <ul> <li>Base units that define the unit.</li> </ul>"},{"location":"types/unit-definition/#baseunit","title":"BaseUnit","text":"<p>Represents a base unit in the unit definition.</p> <p>kind* <code>UnitType</code></p> <ul> <li>Kind of the base unit (e.g., meter, kilogram, second).</li> </ul> <p>exponent* <code>integer</code></p> <ul> <li>Exponent of the base unit in the unit definition.</li> </ul> <p>multiplier <code>float</code></p> <ul> <li>Multiplier of the base unit in the unit definition.</li> </ul> <p>scale <code>float</code></p> <ul> <li>Scale of the base unit in the unit definition.</li> </ul>"},{"location":"types/unit-definition/#enumerations","title":"Enumerations","text":""},{"location":"types/unit-definition/#unittype","title":"UnitType","text":"Alias Value <code>AMPERE</code> ampere <code>AVOGADRO</code> avogadro <code>BECQUEREL</code> becquerel <code>CANDELA</code> candela <code>CELSIUS</code> celsius <code>COULOMB</code> coulomb <code>DIMENSIONLESS</code> dimensionless <code>FARAD</code> farad <code>GRAM</code> gram <code>GRAY</code> gray <code>HENRY</code> henry <code>HERTZ</code> hertz <code>ITEM</code> item <code>JOULE</code> joule <code>KATAL</code> katal <code>KELVIN</code> kelvin <code>KILOGRAM</code> kilogram <code>LITRE</code> litre <code>LUMEN</code> lumen <code>LUX</code> lux <code>METRE</code> metre <code>MOLE</code> mole <code>NEWTON</code> newton <code>OHM</code> ohm <code>PASCAL</code> pascal <code>RADIAN</code> radian <code>SECOND</code> second <code>SIEMENS</code> siemens <code>SIEVERT</code> sievert <code>STERADIAN</code> steradian <code>TESLA</code> tesla <code>VOLT</code> volt <code>WATT</code> watt <code>WEBER</code> weber"}]}